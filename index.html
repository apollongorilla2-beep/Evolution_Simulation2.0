<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Evolution Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            background-color: #222;
            overflow-y: auto;
            font-family: sans-serif;
            color: white;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px;
        }
        .main-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        canvas.simulator {
            border: 2px solid #555;
            background-color: #333;
        }
        #controls {
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            text-align: center;
            min-width: 200px;
        }
        #controls button, #controls input[type="range"] {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
            border: none;
            background-color: #4CAF50;
            color: white;
            border-radius: 4px;
            font-size: 1em;
            transition: background-color 0.2s ease;
            width: calc(100% - 10px); /* Adjust for padding */
            box-sizing: border-box;
        }
        #controls button:hover {
            background-color: #45a049;
        }
        #controls label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        #controls .slider-group {
            margin-bottom: 15px;
        }
        #resetOptions {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #555;
        }
        #resetOptions button {
            background-color: #008CBA;
        }
        #resetOptions button:hover {
            background-color: #007bb5;
        }
        #resetOptions #majorityMaxAgeButton {
            background-color: #f44336;
        }
        #resetOptions #majorityMaxAgeButton:hover {
            background-color: #da190b;
        }
        .chart-container {
            width: 800px;
            height: 400px;
            background-color: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .chart-container h3 {
            text-align: center;
            margin-top: 0;
            color: #eee;
        }

        /* Side Panel for Neural Networks */
        .side-panel {
            width: 350px;
            background-color: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-sizing: border-box;
        }
        .side-panel h2 {
            text-align: center;
            margin-top: 0;
            color: #eee;
        }
        .creature-brain-display {
            background-color: rgba(50,50,50,0.7);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .creature-brain-display h4 {
            margin: 0 0 10px 0;
            color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        .creature-brain-display .color-box {
            width: 15px;
            height: 15px;
            border: 1px solid #777;
            display: inline-block;
            vertical-align: middle;
        }
        .brain-canvas {
            width: 100%;
            height: 200px;
            background-color: #444;
            border: 1px solid #666;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div id="controls">
            <p>Current Generation: <span id="generationCount">0</span></p>
            <p>Alive Population: <span id="populationCount">0</span></p>
            <p>Generation Progress: <span id="generationProgress">0%</span></p>
            <p>Reset Mode: <span id="resetMode">Majority Max Age</span></p>
            <button id="resetButton">Start Simulation</button>

            <div class="slider-group">
                <label for="animationSpeedSlider">Animation Speed: <span id="animationSpeedValue">60</span> FPS</label>
                <input type="range" id="animationSpeedSlider" min="10" max="120" value="60">
            </div>
            <div class="slider-group">
                <label for="mutationRateSlider">Mutation Rate: <span id="mutationRateValue">0.15</span></label>
                <input type="range" id="mutationRateSlider" min="0.01" max="0.5" value="0.15" step="0.01">
            </div>
            <div class="slider-group">
                <label for="mutationStrengthSlider">Mutation Strength: <span id="mutationStrengthValue">0.8</span></label>
                <input type="range" id="mutationStrengthSlider" min="0.1" max="2.0" value="0.8" step="0.1">
            </div>
            <div class="slider-group">
                <label for="foodCountSlider">Food Count: <span id="foodCountValue">300</span></label>
                <input type="range" id="foodCountSlider" min="50" max="1000" value="300" step="10">
            </div>
            <div class="slider-group">
                <label for="maxAgeSlider">Max Creature Age: <span id="maxAgeValue">50</span>s</label>
                <input type="range" id="maxAgeSlider" min="10" max="120" value="50" step="5">
            </div>
            <div class="slider-group">
                <label for="visionRangeSlider">Vision Range: <span id="visionRangeValue">100</span>px</label>
                <input type="range" id="visionRangeSlider" min="50" max="300" value="100" step="10">
            </div>

            <button id="toggleFoodButton">Toggle Food Visibility</button>
            <button id="toggleBiomesButton">Toggle Biome Visibility</button>

            <div id="resetOptions">
                <h4>Set Generation Length:</h4>
                <button id="majorityMaxAgeButton">Majority Max Age</button>
                <button id="reset1sButton">1s Generation</button>
                <button id="reset3sButton">3s Generation</button>
                <button id="reset5sButton">5s Generation</button>
                <button id="reset10sButton">10s Generation</button>
            </div>
        </div>

        <canvas id="evolutionCanvas" class="simulator" width="800" height="600"></canvas>

        <div class="chart-container">
            <h3>Average Fitness Over Generations</h3>
            <canvas id="fitnessChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Population Over Generations</h3>
            <canvas id="populationChart"></canvas>
        </div>

        <div class="chart-container">
            <h3>Average Speed Over Generations</h3>
            <canvas id="speedChart"></canvas>
        </div>

        <div class="chart-container">
            <h3>Average Size Over Generations</h3>
            <canvas id="sizeChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Average Food Eaten Per Generation</h3>
            <canvas id="foodEatenChart"></canvas>
        </div>
        <div class="chart-container">
            <h3>Average Vision Range Over Generations</h3>
            <canvas id="visionRangeChart"></canvas>
        </div>
    </div>

    <div class="side-panel">
        <h2>Top 3 Creature Brains</h2>
        <div id="brainDisplay1" class="creature-brain-display">
            <h4>Creature 1 <span class="color-box" style="background-color: gray;"></span></h4>
            <canvas class="brain-canvas" width="300" height="200"></canvas>
        </div>
        <div id="brainDisplay2" class="creature-brain-display">
            <h4>Creature 2 <span class="color-box" style="background-color: gray;"></span></h4>
            <canvas class="brain-canvas" width="300" height="200"></canvas>
        </div>
        <div id="brainDisplay3" class="creature-brain-display">
            <h4>Creature 3 <span class="color-box" style="background-color: gray;"></span></h4>
            <canvas class="brain-canvas" width="300" height="200"></canvas>
        </div>
    </div>

    <script>
        // --- Simulation Configuration Constants ---
        const SIM_CONFIG = {
            WORLD_WIDTH: 800,
            WORLD_HEIGHT: 600,
            FIXED_POPULATION_SIZE: 100,
            CREATURE_BASE_RADIUS: 5,
            ENERGY_DECAY_BASE: 0.03,
            ENERGY_FROM_FOOD: 100,
            REPRODUCTION_THRESHOLD: 250,
            BASE_SPEED: 1.5,
            WALL_HIT_PENALTY: 10,
            PARENT_SELECTION_PERCENTAGE: 0.2,
            BIOME_GRID_X: 4,
            BIOME_GRID_Y: 3,
            MAX_DATA_POINTS: 500, // Max data points for charts
            FOOD_SPAWN_MULTIPLIER: 10, // Multiplier for biome food spawn chance
            COLLISION_RADIUS_OFFSET: 3, // Additional radius for food collision
            BRAIN_INPUT_NODES: 7, // Food Angle, Food Dist, Energy, Wall X Dist, Wall Y Dist, Biome Type, Vision Range
            BRAIN_HIDDEN_NODES: 8, // Increased hidden nodes for more complexity
            BRAIN_OUTPUT_NODES: 2, // Turn Rate, Speed Adjustment
            MAX_TURN_RATE: 0.4, // Max turn rate in radians
            MAX_SPEED_ADJUSTMENT: 1.0, // Max speed adjustment factor
            INITIAL_VISION_RANGE: 100,
        };

        // Biome Definitions - moved here for centralization
        const BIOME_TYPES = [
            { type: 'grassland', color: '#558B2F', movement_cost_multiplier: 1.0, food_spawn_chance: 0.005, base_adaptation_score: 1.0, description: 'Normal movement, average food.' },
            { type: 'desert', color: '#FFCC80', movement_cost_multiplier: 1.2, food_spawn_chance: 0.002, base_adaptation_score: 0.8, description: 'Slower movement, less food.' },
            { type: 'water', color: '#42A5F5', movement_cost_multiplier: 1.5, food_spawn_chance: 0.008, base_adaptation_score: 1.2, description: 'Harder to move, but more food.' },
            { type: 'forest', color: '#2E7D32', movement_cost_multiplier: 1.1, food_spawn_chance: 0.006, base_adaptation_score: 1.1, description: 'Slightly slower, good food.' },
            { type: 'mountain', color: '#757575', movement_cost_multiplier: 1.8, food_spawn_chance: 0.001, base_adaptation_score: 0.7, description: 'Very slow movement, sparse food.' },
        ];

        // --- Utility Functions ---
        /**
         * Clamps a value between a minimum and maximum.
         * @param {number} value - The value to clamp.
         * @param {number} min - The minimum allowed value.
         * @param {number} max - The maximum allowed value.
         * @returns {number} The clamped value.
         */
        const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

        /**
         * Normalizes an angle to be between 0 and 2*PI.
         * @param {number} angle - The angle to normalize.
         * @returns {number} The normalized angle.
         */
        const normalizeAngle = (angle) => {
            let normalized = angle % (2 * Math.PI);
            if (normalized < 0) {
                normalized += (2 * Math.PI);
            }
            return normalized;
        };

        // --- Neural Network Class ---
        class NeuralNetwork {
            /**
             * Creates a new NeuralNetwork instance.
             * @param {number} inputNodes - Number of input neurons.
             * @param {number} hiddenNodes - Number of hidden neurons.
             * @param {number} outputNodes - Number of output neurons.
             */
            constructor(inputNodes, hiddenNodes, outputNodes) {
                this.inputNodes = inputNodes;
                this.hiddenNodes = hiddenNodes;
                this.outputNodes = outputNodes;

                // Initialize weights and biases randomly
                this.weights_ih = this.createRandomMatrix(this.inputNodes, this.hiddenNodes);
                this.bias_h = this.createRandomArray(this.hiddenNodes);

                this.weights_ho = this.createRandomMatrix(this.hiddenNodes, this.outputNodes);
                this.bias_o = this.createRandomArray(this.outputNodes);
            }

            /**
             * Creates a matrix with random values between -1 and 1.
             * @param {number} rows - Number of rows.
             * @param {number} cols - Number of columns.
             * @returns {number[][]} A new matrix.
             */
            createRandomMatrix(rows, cols) {
                return Array(rows).fill(0).map(() =>
                    Array(cols).fill(0).map(() => (Math.random() - 0.5) * 2)
                );
            }

            /**
             * Creates an array with random values between -1 and 1.
             * @param {number} size - Size of the array.
             * @returns {number[]} A new array.
             */
            createRandomArray(size) {
                return Array(size).fill(0).map(() => (Math.random() - 0.5) * 2);
            }

            /**
             * Performs matrix multiplication (dot product).
             * @param {number[]} a - Input vector.
             * @param {number[][]} b - Weight matrix.
             * @returns {number[]} Resulting vector.
             */
            matrixMultiply(a, b) {
                const result = Array(b[0].length).fill(0);
                for (let j = 0; j < b[0].length; j++) {
                    for (let i = 0; i < a.length; i++) {
                        result[j] += a[i] * b[i][j];
                    }
                }
                return result;
            }

            /**
             * ReLU activation function.
             * @param {number} x - Input value.
             * @returns {number} Activated value.
             */
            relu(x) { return Math.max(0, x); }

            /**
             * Tanh activation function.
             * @param {number} x - Input value.
             * @returns {number} Activated value.
             */
            tanh(x) { return Math.tanh(x); }

            /**
             * Feeds inputs through the neural network to get outputs.
             * @param {number[]} inputs - Array of normalized input values.
             * @returns {number[]} Array of output values.
             */
            feedForward(inputs) {
                // Hidden layer calculation
                let hidden = this.matrixMultiply(inputs, this.weights_ih);
                hidden = hidden.map((val, i) => this.relu(val + this.bias_h[i]));

                // Output layer calculation
                let outputs = this.matrixMultiply(hidden, this.weights_ho);
                outputs = outputs.map((val, i) => this.tanh(val + this.bias_o[i]));

                return outputs;
            }

            /**
             * Creates a new brain by cloning and mutating a parent's brain.
             * @param {NeuralNetwork} parentBrain - The brain of the parent.
             * @param {number} parentFitness - The fitness of the parent, used for adaptive mutation.
             * @param {number} mutationRate - The global mutation rate.
             * @param {number} mutationStrength - The global mutation strength.
             * @returns {NeuralNetwork} A new, mutated NeuralNetwork instance.
             */
            cloneAndMutate(parentBrain, parentFitness, mutationRate, mutationStrength) {
                const newBrain = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);

                // Helper to mutate a gene value
                const mutateGene = (gene, currentMutationStrength) => {
                    if (Math.random() < mutationRate) {
                        return gene + (Math.random() - 0.5) * currentMutationStrength * 2;
                    }
                    return gene;
                };

                let effectiveMutationStrength = mutationStrength;
                // Adaptive mutation strength based on parent's fitness
                if (parentFitness > 5000) { // Very fit parent, reduce mutation for "fine-tuning"
                    effectiveMutationStrength *= 0.6;
                } else if (parentFitness < 1000) { // Less fit parent, increase mutation for "exploration"
                    effectiveMutationStrength *= 1.4;
                }

                newBrain.weights_ih = parentBrain.weights_ih.map(row =>
                    row.map(val => mutateGene(val, effectiveMutationStrength))
                );
                newBrain.bias_h = parentBrain.bias_h.map(val =>
                    mutateGene(val, effectiveMutationStrength)
                );
                newBrain.weights_ho = parentBrain.weights_ho.map(row =>
                    row.map(val => mutateGene(val, effectiveMutationStrength))
                );
                newBrain.bias_o = parentBrain.bias_o.map(val =>
                    mutateGene(val, effectiveMutationStrength)
                );

                return newBrain;
            }

            /**
             * Performs uniform crossover between two parent brains.
             * @param {NeuralNetwork} brain1 - The first parent's brain.
             * @param {NeuralNetwork} brain2 - The second parent's brain.
             * @returns {NeuralNetwork} A new brain resulting from crossover.
             */
            static crossover(brain1, brain2) {
                const newBrain = new NeuralNetwork(brain1.inputNodes, brain1.hiddenNodes, brain1.outputNodes);

                // Helper to perform crossover on a gene array/matrix
                const doCrossover = (genes1, genes2, isMatrix = false) => {
                    const offspringGenes = [];
                    if (isMatrix) {
                        for (let i = 0; i < genes1.length; i++) {
                            offspringGenes[i] = [];
                            for (let j = 0; j < genes1[i].length; j++) {
                                offspringGenes[i][j] = Math.random() < 0.5 ? genes1[i][j] : genes2[i][j];
                            }
                        }
                    } else {
                        for (let i = 0; i < genes1.length; i++) {
                            offspringGenes[i] = Math.random() < 0.5 ? genes1[i] : genes2[i];
                        }
                    }
                    return offspringGenes;
                };

                newBrain.weights_ih = doCrossover(brain1.weights_ih, brain2.weights_ih, true);
                newBrain.bias_h = doCrossover(brain1.bias_h, brain2.bias_h);
                newBrain.weights_ho = doCrossover(brain1.weights_ho, brain2.weights_ho, true);
                newBrain.bias_o = doCrossover(brain1.bias_o, brain2.bias_o);

                return newBrain;
            }
        }

        // --- Food Class ---
        class Food {
            /**
             * Creates a new Food instance.
             * @param {number} x - X coordinate.
             * @param {number} y - Y coordinate.
             */
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.color = 'lime';
            }

            /**
             * Draws the food on the canvas.
             * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
             * @param {boolean} showFood - Whether food should be visible.
             */
            draw(ctx, showFood) {
                if (!showFood) return;

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // --- Creature Class ---
        class Creature {
            /**
             * Creates a new Creature instance.
             * @param {number} x - Initial X position.
             * @param {number} y - Initial Y position.
             * @param {string} [color=null] - Creature's color. If null, a random color is generated.
             * @param {number} [speed=SIM_CONFIG.BASE_SPEED] - Creature's movement speed.
             * @param {number} [size=SIM_CONFIG.CREATURE_BASE_RADIUS] - Creature's size (radius).
             * @param {NeuralNetwork} [brain=null] - Creature's neural network. If null, a new one is created.
             * @param {number} [visionRange=SIM_CONFIG.INITIAL_VISION_RANGE] - Creature's vision range.
             */
            constructor(x, y, color = null, speed = SIM_CONFIG.BASE_SPEED, size = SIM_CONFIG.CREATURE_BASE_RADIUS, brain = null, visionRange = SIM_CONFIG.INITIAL_VISION_RANGE) {
                this.x = x;
                this.y = y;
                this.originalColor = color || '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                this.color = this.originalColor;
                this.speed = speed;
                this.size = size;
                this.energy = 100;
                this.age = 0;
                this.direction = Math.random() * Math.PI * 2;
                this.foodEatenCount = 0;
                this.isAlive = true;
                this.fitness = 0; // Stored fitness from previous generation for selection and adaptive mutation
                this.visionRange = visionRange;

                this.brain = brain || new NeuralNetwork(
                    SIM_CONFIG.BRAIN_INPUT_NODES,
                    SIM_CONFIG.BRAIN_HIDDEN_NODES,
                    SIM_CONFIG.BRAIN_OUTPUT_NODES
                );
                this.trail = []; // For visual trails
                this.maxTrailLength = 30;
            }

            /**
             * Determines the current biome the creature is in.
             * @param {number[][]} biomeMap - The global biome map.
             * @returns {object} The biome type object.
             */
            getBiome(biomeMap) {
                const biomeX = Math.floor(this.x / (SIM_CONFIG.WORLD_WIDTH / SIM_CONFIG.BIOME_GRID_X));
                const biomeY = Math.floor(this.y / (SIM_CONFIG.WORLD_HEIGHT / SIM_CONFIG.BIOME_GRID_Y));
                const clampedX = clamp(biomeX, 0, SIM_CONFIG.BIOME_GRID_X - 1);
                const clampedY = clamp(biomeY, 0, SIM_CONFIG.BIOME_GRID_Y - 1);
                return BIOME_TYPES[biomeMap[clampedY][clampedX]];
            }

            /**
             * The creature's "thinking" process using its neural network.
             * @param {Food[]} globalFood - Array of all food items.
             * @param {number[][]} biomeMap - The global biome map.
             * @returns {{turnRate: number, speedAdjustment: number}} The actions determined by the brain.
             */
            think(globalFood, biomeMap) {
                // Gather inputs (normalized 0-1)
                let foodAngleInput = 0.5; // Neutral if no food
                let foodDistanceInput = 0; // Farthest if no food (0 implies no food, 1 implies very close)
                let closestFood = null;
                let minFoodDistance = Infinity;

                // Find closest food within vision range
                for (const f of globalFood) {
                    const dist = Math.sqrt((this.x - f.x) ** 2 + (this.y - f.y) ** 2);
                    if (dist < minFoodDistance && dist <= this.visionRange) {
                        minFoodDistance = dist;
                        closestFood = f;
                    }
                }

                if (closestFood) {
                    const angleToFood = Math.atan2(closestFood.y - this.y, closestFood.x - this.x);
                    let relativeAngle = normalizeAngle(angleToFood - this.direction);
                    foodAngleInput = relativeAngle / (2 * Math.PI);

                    // Normalize food distance: closer is higher value (1 is closest, 0 is furthest within vision)
                    foodDistanceInput = 1 - (minFoodDistance / this.visionRange);
                }

                // Creature energy (normalized)
                let energyInput = clamp(this.energy / (SIM_CONFIG.REPRODUCTION_THRESHOLD * 2), 0, 1);

                // Distance to nearest horizontal wall (normalized: 0 is wall, 1 is center)
                let wallXDistanceInput = Math.min(this.x, SIM_CONFIG.WORLD_WIDTH - this.x);
                wallXDistanceInput = wallXDistanceInput / (SIM_CONFIG.WORLD_WIDTH / 2);

                // Distance to nearest vertical wall (normalized: 0 is wall, 1 is center)
                let wallYDistanceInput = Math.min(this.y, SIM_CONFIG.WORLD_HEIGHT - this.y);
                wallYDistanceInput = wallYDistanceInput / (SIM_CONFIG.WORLD_HEIGHT / 2);

                // Biome type input (normalized index)
                const currentBiomeIndex = biomeMap[Math.floor(this.y / (SIM_CONFIG.WORLD_HEIGHT / SIM_CONFIG.BIOME_GRID_Y))][Math.floor(this.x / (SIM_CONFIG.WORLD_WIDTH / SIM_CONFIG.BIOME_GRID_X))];
                const biomeInput = currentBiomeIndex / (BIOME_TYPES.length - 1);

                // Vision Range input (normalized)
                let visionRangeInput = clamp(this.visionRange / 300, 0, 1); // Max vision range is 300 from slider

                const inputs = [foodAngleInput, foodDistanceInput, energyInput, wallXDistanceInput, wallYDistanceInput, biomeInput, visionRangeInput];

                const outputs = this.brain.feedForward(inputs);

                // Map outputs to actions: turn rate and speed adjustment
                const turnRate = outputs[0] * SIM_CONFIG.MAX_TURN_RATE;
                const speedAdjustment = outputs[1] * SIM_CONFIG.MAX_SPEED_ADJUSTMENT;

                return { turnRate, speedAdjustment };
            }

            /**
             * Draws the creature on the canvas.
             * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
             */
            draw(ctx) {
                if (!this.isAlive) {
                    // Draw dead creatures as smaller, greyed-out circles
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 0.7, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(50, 50, 50, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    return;
                }

                // Draw trail
                ctx.beginPath();
                const colorR = parseInt(this.color.substring(1, 3), 16);
                const colorG = parseInt(this.color.substring(3, 5), 16);
                const colorB = parseInt(this.color.substring(5, 7), 16);
                ctx.strokeStyle = `rgba(${colorR}, ${colorG}, ${colorB}, 0.3)`;
                ctx.lineWidth = 1;
                if (this.trail.length > 1) {
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                }
                ctx.stroke();

                // Draw creature body
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw a small "eye" to indicate direction
                ctx.beginPath();
                const eyeX = this.x + Math.cos(this.direction) * (this.size * 0.7);
                const eyeY = this.y + Math.sin(this.direction) * (this.size * 0.7);
                ctx.arc(eyeX, eyeY, this.size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
            }

            /**
             * Updates the creature's state each frame.
             * @param {number[][]} biomeMap - The global biome map.
             * @param {Food[]} globalFood - Array of all food items.
             * @param {number} mutationRate - Current mutation rate.
             * @param {number} mutationStrength - Current mutation strength.
             */
            update(biomeMap, globalFood, mutationRate, mutationStrength) {
                this.age++;

                const currentBiome = this.getBiome(biomeMap);
                this.energy -= SIM_CONFIG.ENERGY_DECAY_BASE * currentBiome.movement_cost_multiplier;

                const { turnRate, speedAdjustment } = this.think(globalFood, biomeMap);
                this.direction = normalizeAngle(this.direction + turnRate);
                this.speed = clamp(SIM_CONFIG.BASE_SPEED + speedAdjustment, 0.5, SIM_CONFIG.BASE_SPEED * 2.5);

                this.x += Math.cos(this.direction) * this.speed;
                this.y += Math.sin(this.direction) * this.speed;

                let hitWall = false;
                if (this.x < this.size) {
                    this.x = this.size;
                    this.direction = Math.PI - this.direction;
                    hitWall = true;
                } else if (this.x > SIM_CONFIG.WORLD_WIDTH - this.size) {
                    this.x = SIM_CONFIG.WORLD_WIDTH - this.size;
                    this.direction = Math.PI - this.direction;
                    hitWall = true;
                }
                if (this.y < this.size) {
                    this.y = this.size;
                    this.direction = -this.direction;
                    hitWall = true;
                } else if (this.y > SIM_CONFIG.WORLD_HEIGHT - this.size) {
                    this.y = SIM_CONFIG.WORLD_HEIGHT - this.size;
                    this.direction = -this.direction;
                    hitWall = true;
                }
                if (hitWall) {
                    this.energy -= SIM_CONFIG.WALL_HIT_PENALTY;
                }

                // Add current position to trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }

                // Creature becomes "not alive" only when it reaches MAX_AGE_FRAMES or runs out of energy
                if (this.age > SIM_CONFIG.MAX_AGE_FRAMES || this.energy <= 0) {
                    this.isAlive = false;
                }
            }

            /**
             * Handles food consumption.
             * @param {number} foodIndex - The index of the food item in the global food array.
             * @param {Food[]} globalFood - The global food array.
             */
            eat(foodIndex, globalFood) {
                this.energy += SIM_CONFIG.ENERGY_FROM_FOOD;
                this.foodEatenCount++;
                globalFood.splice(foodIndex, 1);
                this.color = 'yellow'; // Flash yellow
                setTimeout(() => {
                    this.color = this.originalColor;
                }, 100);
            }

            /**
             * Calculates the creature's fitness for selection.
             * @param {number[][]} biomeMap - The global biome map.
             * @returns {number} The calculated fitness score.
             */
            calculateFitness(biomeMap) {
                let baseFitness = this.foodEatenCount * 200; // Increased food reward
                baseFitness += this.age * 0.8; // Reward for surviving longer
                baseFitness += Math.max(0, this.energy) * 0.2; // Reward for remaining energy (cannot be negative)
                baseFitness -= (this.age > SIM_CONFIG.MAX_AGE_FRAMES ? 0 : (SIM_CONFIG.MAX_AGE_FRAMES - this.age)) * 0.02; // Small penalty for not reaching max age

                // Reward for being in a biome it's adapted to (or penalize for being in a bad one)
                const currentBiome = this.getBiome(biomeMap);
                baseFitness += currentBiome.base_adaptation_score * 75; // Increased biome adaptation reward

                // Reward for optimal speed (not too fast, not too slow)
                const speedDifference = Math.abs(this.speed - SIM_CONFIG.BASE_SPEED);
                baseFitness -= speedDifference * 10; // Penalty for deviating too much from base speed

                // Reward for efficient vision range
                baseFitness -= Math.abs(this.visionRange - SIM_CONFIG.INITIAL_VISION_RANGE) * 0.5; // Small penalty for deviating from initial vision

                return Math.max(0, baseFitness); // Fitness cannot be negative
            }

            /**
             * Mutates the creature's color for visual diversity.
             * @param {string} originalColor - The original color string (e.g., '#RRGGBB').
             * @param {number} mutationRate - The current mutation rate.
             * @returns {string} The new mutated color.
             */
            mutateColor(originalColor, mutationRate) {
                const hex = originalColor.substring(1);
                let r = parseInt(hex.substring(0, 2), 16);
                let g = parseInt(hex.substring(2, 4), 16);
                let b = parseInt(hex.substring(4, 6), 16);

                if (Math.random() < mutationRate * 2) r = clamp(r + Math.floor((Math.random() - 0.5) * 60), 0, 255);
                if (Math.random() < mutationRate * 2) g = clamp(g + Math.floor((Math.random() - 0.5) * 60), 0, 255);
                if (Math.random() < mutationRate * 2) b = clamp(b + Math.floor((Math.random() - 0.5) * 60), 0, 255);

                return '#' +
                    Math.round(r).toString(16).padStart(2, '0') +
                    Math.round(g).toString(16).padStart(2, '0') +
                    Math.round(b).toString(16).padStart(2, '0');
            }

            /**
             * Mutates a creature's vision range.
             * @param {number} parentVisionRange - The parent's vision range.
             * @param {number} mutationRate - The current mutation rate.
             * @param {number} mutationStrength - The current mutation strength.
             * @returns {number} The new mutated vision range.
             */
            mutateVisionRange(parentVisionRange, mutationRate, mutationStrength) {
                if (Math.random() < mutationRate) {
                    return clamp(parentVisionRange + (Math.random() - 0.5) * mutationStrength * 50, 50, 300);
                }
                return parentVisionRange;
            }
        }

        // --- Chart Manager Module ---
        const ChartManager = {
            generationLabels: [],
            fitnessData: [],
            populationData: [],
            speedData: [],
            sizeData: [],
            foodEatenData: [],
            visionRangeData: [], // New chart data for vision range

            fitnessChart: null,
            populationChart: null,
            speedChart: null,
            sizeChart: null,
            foodEatenChart: null,
            visionRangeChart: null, // New chart instance

            /**
             * Initializes all Chart.js instances.
             */
            initCharts() {
                if (typeof Chart === 'undefined') {
                    console.error("Chart.js is not loaded. Cannot initialize charts. Please ensure the Chart.js script is accessible.");
                    return;
                }

                const chartOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Generation', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'Value', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: 'white' } }
                    }
                };

                // Destroy existing charts to prevent memory leaks
                this.destroyCharts();

                this.fitnessChart = new Chart(document.getElementById('fitnessChart'), {
                    type: 'line', data: { labels: this.generationLabels, datasets: [{ label: 'Average Fitness', data: this.fitnessData, borderColor: 'rgb(255, 159, 64)', tension: 0.1, fill: false }] },
                    options: { ...chartOptions, scales: { ...chartOptions.scales, y: { ...chartOptions.scales.y, min: 0 } } }
                });
                this.populationChart = new Chart(document.getElementById('populationChart'), {
                    type: 'line', data: { labels: this.generationLabels, datasets: [{ label: 'Population (Alive)', data: this.populationData, borderColor: 'rgb(75, 192, 192)', tension: 0.1, fill: false }] },
                    options: { ...chartOptions, scales: { ...chartOptions.scales, y: { ...chartOptions.scales.y, min: 0, max: SIM_CONFIG.FIXED_POPULATION_SIZE * 1.1 } } }
                });
                this.speedChart = new Chart(document.getElementById('speedChart'), {
                    type: 'line', data: { labels: this.generationLabels, datasets: [{ label: 'Average Speed', data: this.speedData, borderColor: 'rgb(255, 99, 132)', tension: 0.1, fill: false }] },
                    options: { ...chartOptions, scales: { ...chartOptions.scales, y: { ...chartOptions.scales.y, min: 0, max: SIM_CONFIG.BASE_SPEED * 2.5 } } }
                });
                this.sizeChart = new Chart(document.getElementById('sizeChart'), {
                    type: 'line', data: { labels: this.generationLabels, datasets: [{ label: 'Average Size', data: this.sizeData, borderColor: 'rgb(54, 162, 235)', tension: 0.1, fill: false }] },
                    options: { ...chartOptions, scales: { ...chartOptions.scales, y: { ...chartOptions.scales.y, min: 0, max: SIM_CONFIG.CREATURE_BASE_RADIUS * 3 } } }
                });
                this.foodEatenChart = new Chart(document.getElementById('foodEatenChart'), {
                    type: 'line', data: { labels: this.generationLabels, datasets: [{ label: 'Avg Food Eaten', data: this.foodEatenData, borderColor: 'rgb(255, 205, 86)', tension: 0.1, fill: false }] },
                    options: { ...chartOptions, scales: { ...chartOptions.scales, y: { ...chartOptions.scales.y, min: 0 } } }
                });
                this.visionRangeChart = new Chart(document.getElementById('visionRangeChart'), {
                    type: 'line', data: { labels: this.generationLabels, datasets: [{ label: 'Avg Vision Range', data: this.visionRangeData, borderColor: 'rgb(153, 102, 255)', tension: 0.1, fill: false }] },
                    options: { ...chartOptions, scales: { ...chartOptions.scales, y: { ...chartOptions.scales.y, min: 0 } } }
                });
            },

            /**
             * Destroys all existing chart instances.
             */
            destroyCharts() {
                if (this.fitnessChart) this.fitnessChart.destroy();
                if (this.populationChart) this.populationChart.destroy();
                if (this.speedChart) this.speedChart.destroy();
                if (this.sizeChart) this.sizeChart.destroy();
                if (this.foodEatenChart) this.foodEatenChart.destroy();
                if (this.visionRangeChart) this.visionRangeChart.destroy();

                this.fitnessChart = null;
                this.populationChart = null;
                this.speedChart = null;
                this.sizeChart = null;
                this.foodEatenChart = null;
                this.visionRangeChart = null;
            },

            /**
             * Clears all chart data.
             */
            clearData() {
                this.generationLabels = [];
                this.fitnessData = [];
                this.populationData = [];
                this.speedData = [];
                this.sizeData = [];
                this.foodEatenData = [];
                this.visionRangeData = [];
            },

            /**
             * Updates data for all charts with the given creature statistics.
             * @param {Creature[]} allCreaturesInGeneration - Array of creatures from the just-finished generation.
             * @param {number} currentGenerationNumber - The current generation number.
             */
            updateChartsData(allCreaturesInGeneration, currentGenerationNumber) {
                if (typeof Chart === 'undefined') { return; }

                this.generationLabels.push(currentGenerationNumber);

                let totalFitness = 0;
                let totalSpeed = 0;
                let totalSize = 0;
                let totalFoodEaten = 0;
                let totalVisionRange = 0;
                let aliveCreaturesCount = 0;

                for (const creature of allCreaturesInGeneration) {
                    totalFitness += creature.fitness; // Use pre-calculated fitness
                    if (creature.isAlive) {
                        totalSpeed += creature.speed;
                        totalSize += creature.size;
                        totalFoodEaten += creature.foodEatenCount;
                        totalVisionRange += creature.visionRange;
                        aliveCreaturesCount++;
                    }
                }

                this.fitnessData.push(totalFitness / allCreaturesInGeneration.length);
                this.populationData.push(aliveCreaturesCount); // Only alive population for this chart

                if (aliveCreaturesCount > 0) {
                    this.speedData.push(totalSpeed / aliveCreaturesCount);
                    this.sizeData.push(totalSize / aliveCreaturesCount);
                    this.foodEatenData.push(totalFoodEaten / aliveCreaturesCount);
                    this.visionRangeData.push(totalVisionRange / aliveCreaturesCount);
                } else {
                    // If no creatures are alive, push 0 for averages
                    this.speedData.push(0);
                    this.sizeData.push(0);
                    this.foodEatenData.push(0);
                    this.visionRangeData.push(0);
                }

                // Limit data points to keep charts performant
                if (this.generationLabels.length > SIM_CONFIG.MAX_DATA_POINTS) {
                    this.generationLabels.shift();
                    this.fitnessData.shift();
                    this.populationData.shift();
                    this.speedData.shift();
                    this.sizeData.shift();
                    this.foodEatenData.shift();
                    this.visionRangeData.shift();
                }

                this.fitnessChart.update();
                this.populationChart.update();
                this.speedChart.update();
                this.sizeChart.update();
                this.foodEatenChart.update();
                this.visionRangeChart.update();
            }
        };

        // --- UI Manager Module ---
        const UIManager = {
            // UI Elements
            generationCountSpan: document.getElementById('generationCount'),
            populationCountSpan: document.getElementById('populationCount'),
            generationProgressSpan: document.getElementById('generationProgress'),
            resetModeSpan: document.getElementById('resetMode'),
            resetButton: document.getElementById('resetButton'),
            majorityMaxAgeButton: document.getElementById('majorityMaxAgeButton'),
            reset1sButton: document.getElementById('reset1sButton'),
            reset3sButton: document.getElementById('reset3sButton'),
            reset5sButton: document.getElementById('reset5sButton'),
            reset10sButton: document.getElementById('reset10sButton'),
            animationSpeedSlider: document.getElementById('animationSpeedSlider'),
            animationSpeedValue: document.getElementById('animationSpeedValue'),
            mutationRateSlider: document.getElementById('mutationRateSlider'),
            mutationRateValue: document.getElementById('mutationRateValue'),
            mutationStrengthSlider: document.getElementById('mutationStrengthSlider'),
            mutationStrengthValue: document.getElementById('mutationStrengthValue'),
            foodCountSlider: document.getElementById('foodCountSlider'),
            foodCountValue: document.getElementById('foodCountValue'),
            maxAgeSlider: document.getElementById('maxAgeSlider'),
            maxAgeValue: document.getElementById('maxAgeValue'),
            visionRangeSlider: document.getElementById('visionRangeSlider'),
            visionRangeValue: document.getElementById('visionRangeValue'),
            toggleFoodButton: document.getElementById('toggleFoodButton'),
            toggleBiomesButton: document.getElementById('toggleBiomesButton'),
            brainDisplays: [
                { container: document.getElementById('brainDisplay1'), title: document.querySelector('#brainDisplay1 h4'), canvas: document.querySelector('#brainDisplay1 .brain-canvas') },
                { container: document.getElementById('brainDisplay2'), title: document.querySelector('#brainDisplay2 h4'), canvas: document.querySelector('#brainDisplay2 .brain-canvas') },
                { container: document.getElementById('brainDisplay3'), title: document.querySelector('#brainDisplay3 h4'), canvas: document.querySelector('#brainDisplay3 .brain-canvas') },
            ],
            brainContexts: [],

            /**
             * Initializes the UI elements and their contexts.
             */
            init() {
                this.brainContexts = this.brainDisplays.map(bd => bd.canvas.getContext('2d'));
            },

            /**
             * Updates the generation count displayed in the UI.
             * @param {number} count - The current generation number.
             */
            updateGenerationCount(count) {
                this.generationCountSpan.textContent = count;
            },

            /**
             * Updates the alive population count displayed in the UI.
             * @param {number} count - The number of alive creatures.
             */
            updatePopulationCount(count) {
                this.populationCountSpan.textContent = count;
            },

            /**
             * Updates the generation progress displayed in the UI.
             * @param {number} progress - The progress percentage (0-100).
             */
            updateGenerationProgress(progress) {
                this.generationProgressSpan.textContent = `${progress}%`;
            },

            /**
             * Updates the displayed reset mode.
             * @param {string} modeText - Text describing the current reset mode.
             */
            updateResetMode(modeText) {
                this.resetModeSpan.textContent = modeText;
            },

            /**
             * Updates the displayed value for a given slider.
             * @param {HTMLElement} valueSpan - The span element displaying the value.
             * @param {number} value - The new value.
             * @param {string} [suffix=''] - Optional suffix for the value (e.g., 'FPS', 's').
             */
            updateSliderValue(valueSpan, value, suffix = '') {
                valueSpan.textContent = value + suffix;
            },

            /**
             * Draws a neural network visualization on a given canvas context.
             * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
             * @param {NeuralNetwork} brain - The neural network to draw.
             * @param {string[]} inputLabels - Labels for input nodes.
             * @param {string[]} outputLabels - Labels for output nodes.
             */
            drawNeuralNetwork(ctx, brain, inputLabels, outputLabels) {
                if (!ctx) return;

                const canvasWidth = ctx.canvas.width;
                const canvasHeight = ctx.canvas.height;
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.fillStyle = '#444';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                const nodeRadius = 8;
                const horizontalSpacing = canvasWidth / 4;

                const inputNodes = brain.inputNodes;
                const hiddenNodes = brain.hiddenNodes;
                const outputNodes = brain.outputNodes;

                const inputYStep = canvasHeight / (inputNodes + 1);
                const hiddenYStep = canvasHeight / (hiddenNodes + 1);
                const outputYStep = canvasHeight / (outputNodes + 1);

                const nodes = { input: [], hidden: [], output: [] };

                // Draw input nodes
                for (let i = 0; i < inputNodes; i++) {
                    const x = horizontalSpacing;
                    const y = (i + 1) * inputYStep;
                    nodes.input.push({ x, y });
                    ctx.beginPath();
                    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = 'lightblue';
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.stroke();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(inputLabels[i], x - nodeRadius - 5, y + 3);
                }

                // Draw hidden nodes
                for (let i = 0; i < hiddenNodes; i++) {
                    const x = horizontalSpacing * 2;
                    const y = (i + 1) * hiddenYStep;
                    nodes.hidden.push({ x, y });
                    ctx.beginPath();
                    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = 'lightcoral';
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.stroke();
                }

                // Draw output nodes
                for (let i = 0; i < outputNodes; i++) {
                    const x = horizontalSpacing * 3;
                    const y = (i + 1) * outputYStep;
                    nodes.output.push({ x, y });
                    ctx.beginPath();
                    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = 'lightgreen';
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.stroke();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(outputLabels[i], x + nodeRadius + 5, y + 3);
                }

                // Draw connections (weights) from input to hidden layer
                for (let i = 0; i < inputNodes; i++) {
                    for (let j = 0; j < hiddenNodes; j++) {
                        const weight = brain.weights_ih[i][j];
                        ctx.beginPath();
                        ctx.moveTo(nodes.input[i].x, nodes.input[i].y);
                        ctx.lineTo(nodes.hidden[j].x, nodes.hidden[j].y);
                        ctx.strokeStyle = weight > 0 ? `rgba(0, 255, 0, ${clamp(Math.abs(weight / 2), 0, 1)})` : `rgba(255, 0, 0, ${clamp(Math.abs(weight / 2), 0, 1)})`;
                        ctx.lineWidth = Math.abs(weight) * 1.5;
                        ctx.stroke();
                    }
                }

                // Draw connections (weights) from hidden to output layer
                for (let i = 0; i < hiddenNodes; i++) {
                    for (let j = 0; j < outputNodes; j++) {
                        const weight = brain.weights_ho[i][j];
                        ctx.beginPath();
                        ctx.moveTo(nodes.hidden[i].x, nodes.hidden[i].y);
                        ctx.lineTo(nodes.output[j].x, nodes.output[j].y);
                        ctx.strokeStyle = weight > 0 ? `rgba(0, 255, 0, ${clamp(Math.abs(weight / 2), 0, 1)})` : `rgba(255, 0, 0, ${clamp(Math.abs(weight / 2), 0, 1)})`;
                        ctx.lineWidth = Math.abs(weight) * 1.5;
                        ctx.stroke();
                    }
                }
            },

            /**
             * Updates the displayed neural networks for the top 3 creatures.
             * @param {Creature[]} creatures - Array of all creatures in the current generation.
             */
            updateBrainDisplays(creatures) {
                // Sort creatures by current food eaten count for display
                const sortedCreaturesForDisplay = [...creatures].sort((a, b) => b.foodEatenCount - a.foodEatenCount);

                const inputLabels = ["F Angle", "F Dist", "Energy", "Wall X", "Wall Y", "Biome", "Vision"];
                const outputLabels = ["Turn Rate", "Speed Adj"];

                for (let i = 0; i < 3; i++) {
                    const display = this.brainDisplays[i];
                    const creature = sortedCreaturesForDisplay[i];

                    if (creature) {
                        const colorBox = display.title.querySelector('.color-box');
                        colorBox.style.backgroundColor = creature.originalColor; // Show original color
                        display.title.innerHTML = `Creature ${i + 1} <span class="color-box" style="background-color: ${creature.originalColor};"></span>`;

                        this.drawNeuralNetwork(this.brainContexts[i], creature.brain, inputLabels, outputLabels);
                    } else {
                        const colorBox = display.title.querySelector('.color-box');
                        colorBox.style.backgroundColor = 'gray';
                        display.title.innerHTML = `Creature ${i + 1} <span class="color-box" style="background-color: gray;"></span>`;
                        if (this.brainContexts[i]) {
                            this.brainContexts[i].clearRect(0, 0, display.canvas.width, display.canvas.height);
                            this.brainContexts[i].fillStyle = '#444';
                            this.brainContexts[i].fillRect(0, 0, display.canvas.width, display.canvas.height);
                        }
                    }
                }
            }
        };

        // --- Simulation Class ---
        class Simulation {
            constructor() {
                this.canvas = document.getElementById('evolutionCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.food = [];
                this.creatures = [];
                this.simulationFrameCount = 0;
                this.currentGenerationNumber = 0;
                this.animationFrameId = null;
                this.lastFrameTime = 0;
                this.msPerFrame = 1000 / 60; // Initial FPS, will be updated by slider

                this.currentGenerationEndMode = 'majorityMaxAge'; // 'majorityMaxAge' or 'fixedTime'
                this.fixedTimeGenerationLengthMs = 0;
                this.lastGenerationStartTime = performance.now();

                this.showFood = true;
                this.showBiomes = true;
                this.biomeMap = [];

                // Tunable parameters (linked to sliders, initialized from SIM_CONFIG defaults)
                this.mutationRate = parseFloat(UIManager.mutationRateSlider.value);
                this.mutationStrength = parseFloat(UIManager.mutationStrengthSlider.value);
                this.foodCount = parseInt(UIManager.foodCountSlider.value);
                this.maxAgeFrames = parseInt(UIManager.maxAgeSlider.value) * 60;
                this.animationFps = parseInt(UIManager.animationSpeedSlider.value);
                this.visionRange = parseInt(UIManager.visionRangeSlider.value);
                this.msPerFrame = 1000 / this.animationFps;


                UIManager.init();
                this.addEventListeners();
                this.initSimulation();
            }

            /**
             * Adds event listeners for UI controls.
             */
            addEventListeners() {
                UIManager.resetButton.addEventListener('click', () => this.initSimulation());
                UIManager.majorityMaxAgeButton.addEventListener('click', () => this.setMajorityMaxAgeMode());
                UIManager.reset1sButton.addEventListener('click', () => this.setFixedTimeGeneration(1));
                UIManager.reset3sButton.addEventListener('click', () => this.setFixedTimeGeneration(3));
                UIManager.reset5sButton.addEventListener('click', () => this.setFixedTimeGeneration(5));
                UIManager.reset10sButton.addEventListener('click', () => this.setFixedTimeGeneration(10));

                UIManager.animationSpeedSlider.addEventListener('input', (e) => {
                    this.animationFps = parseInt(e.target.value);
                    UIManager.updateSliderValue(UIManager.animationSpeedValue, this.animationFps, ' FPS');
                    this.msPerFrame = 1000 / this.animationFps;
                });
                UIManager.mutationRateSlider.addEventListener('input', (e) => {
                    this.mutationRate = parseFloat(e.target.value);
                    UIManager.updateSliderValue(UIManager.mutationRateValue, this.mutationRate);
                });
                UIManager.mutationStrengthSlider.addEventListener('input', (e) => {
                    this.mutationStrength = parseFloat(e.target.value);
                    UIManager.updateSliderValue(UIManager.mutationStrengthValue, this.mutationStrength);
                });
                UIManager.foodCountSlider.addEventListener('input', (e) => {
                    this.foodCount = parseInt(e.target.value);
                    UIManager.updateSliderValue(UIManager.foodCountValue, this.foodCount);
                    if (this.currentGenerationNumber > 0) {
                        this.resetAndSpawnAllFood(this.foodCount);
                    }
                });
                UIManager.maxAgeSlider.addEventListener('input', (e) => {
                    this.maxAgeFrames = parseInt(e.target.value) * 60;
                    UIManager.updateSliderValue(UIManager.maxAgeValue, parseInt(e.target.value), 's');
                });
                UIManager.visionRangeSlider.addEventListener('input', (e) => {
                    this.visionRange = parseInt(e.target.value);
                    UIManager.updateSliderValue(UIManager.visionRangeValue, this.visionRange, 'px');
                });

                UIManager.toggleFoodButton.addEventListener('click', () => {
                    this.showFood = !this.showFood;
                    UIManager.toggleFoodButton.textContent = this.showFood ? 'Hide Food' : 'Show Food';
                });
                UIManager.toggleBiomesButton.addEventListener('click', () => {
                    this.showBiomes = !this.showBiomes;
                    UIManager.toggleBiomesButton.textContent = this.showBiomes ? 'Hide Biomes' : 'Show Biomes';
                });
            }

            /**
             * Sets the generation end mode to "Majority Max Age".
             */
            setMajorityMaxAgeMode() {
                this.currentGenerationEndMode = 'majorityMaxAge';
                UIManager.updateResetMode('Majority Max Age');
            }

            /**
             * Sets the generation end mode to a fixed time.
             * @param {number} seconds - The duration of the generation in seconds.
             */
            setFixedTimeGeneration(seconds) {
                this.currentGenerationEndMode = 'fixedTime';
                this.fixedTimeGenerationLengthMs = seconds * 1000;
                UIManager.updateResetMode(`${seconds}s Generation`);
                this.lastGenerationStartTime = performance.now();
            }

            /**
             * Generates a new random biome map.
             */
            generateBiomeMap() {
                this.biomeMap = [];
                const biomeTypesCount = BIOME_TYPES.length;
                for (let y = 0; y < SIM_CONFIG.BIOME_GRID_Y; y++) {
                    this.biomeMap[y] = [];
                    for (let x = 0; x < SIM_CONFIG.BIOME_GRID_X; x++) {
                        this.biomeMap[y][x] = Math.floor(Math.random() * biomeTypesCount);
                    }
                }
            }

            /**
             * Draws the biome grid on the canvas.
             */
            drawBiomes() {
                if (!this.showBiomes) return;

                const cellWidth = SIM_CONFIG.WORLD_WIDTH / SIM_CONFIG.BIOME_GRID_X;
                const cellHeight = SIM_CONFIG.WORLD_HEIGHT / SIM_CONFIG.BIOME_GRID_Y;
                for (let y = 0; y < SIM_CONFIG.BIOME_GRID_Y; y++) {
                    for (let x = 0; x < SIM_CONFIG.BIOME_GRID_X; x++) {
                        const biomeType = BIOME_TYPES[this.biomeMap[y][x]];
                        this.ctx.fillStyle = biomeType.color;
                        this.ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);

                        this.ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
            }

            /**
             * Clears all food and spawns a new set.
             * @param {number} count - The number of food items to spawn.
             */
            resetAndSpawnAllFood(count) {
                this.food = [];
                this.spawnFood(count);
            }

            /**
             * Spawns a specified number of food items, preferring certain biomes.
             * @param {number} count - The number of food items to spawn.
             */
            spawnFood(count) {
                for (let i = 0; i < count; i++) {
                    let randomX, randomY;
                    let placed = false;
                    let attempts = 0;
                    const maxBiomeSpawnAttempts = 50;

                    while (!placed && attempts < maxBiomeSpawnAttempts) {
                        randomX = Math.random() * SIM_CONFIG.WORLD_WIDTH;
                        randomY = Math.random() * SIM_CONFIG.WORLD_HEIGHT;
                        const biomeX = Math.floor(randomX / (SIM_CONFIG.WORLD_WIDTH / SIM_CONFIG.BIOME_GRID_X));
                        const biomeY = Math.floor(randomY / (SIM_CONFIG.WORLD_HEIGHT / SIM_CONFIG.BIOME_GRID_Y));
                        const clampedX = clamp(biomeX, 0, SIM_CONFIG.BIOME_GRID_X - 1);
                        const clampedY = clamp(biomeY, 0, SIM_CONFIG.BIOME_GRID_Y - 1);
                        const biome = BIOME_TYPES[this.biomeMap[clampedY][clampedX]];

                        if (Math.random() < biome.food_spawn_chance * SIM_CONFIG.FOOD_SPAWN_MULTIPLIER) {
                            this.food.push(new Food(randomX, randomY));
                            placed = true;
                        }
                        attempts++;
                    }

                    if (!placed) { // If unable to place in a preferred biome after attempts, place anywhere
                        randomX = Math.random() * SIM_CONFIG.WORLD_WIDTH;
                        randomY = Math.random() * SIM_CONFIG.WORLD_HEIGHT;
                        this.food.push(new Food(randomX, randomY));
                    }
                }
            }

            /**
             * Replenishes food if the current count is below target.
             * @param {number} count - The number of food items to replenish.
             */
            replenishFood(count) {
                if (this.food.length < this.foodCount) {
                    this.spawnFood(count);
                }
            }

            /**
             * Initializes the entire simulation.
             */
            initSimulation() {
                this.currentGenerationNumber = 0;
                ChartManager.clearData();
                ChartManager.initCharts();
                this.generateBiomeMap();

                const initialCreatures = Array(SIM_CONFIG.FIXED_POPULATION_SIZE).fill(null).map(() => new Creature(
                    Math.random() * SIM_CONFIG.WORLD_WIDTH,
                    Math.random() * SIM_CONFIG.WORLD_HEIGHT,
                    null, // random color
                    SIM_CONFIG.BASE_SPEED + (Math.random() - 0.5), // initial varied speed
                    SIM_CONFIG.CREATURE_BASE_RADIUS + (Math.random() - 0.5) * 2, // initial varied size
                    null, // new brain
                    this.visionRange + (Math.random() - 0.5) * 50 // initial varied vision range
                ));

                this.setMajorityMaxAgeMode(); // Set default reset mode
                this.startNewGeneration(initialCreatures);

                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                this.lastFrameTime = 0;
                this.gameLoop();
            }

            /**
             * Ends the current generation and prepares the next one.
             */
            endGenerationAndStartNewOne() {
                const allCreaturesInGeneration = [...this.creatures];

                // Calculate fitness for all creatures before updating charts or selecting parents
                for (const creature of allCreaturesInGeneration) {
                    creature.fitness = creature.calculateFitness(this.biomeMap);
                }

                ChartManager.updateChartsData(allCreaturesInGeneration, this.currentGenerationNumber);

                // Sort creatures by fitness to select the fittest parents
                const sortedCreatures = [...allCreaturesInGeneration].sort((a, b) => b.fitness - a.fitness);

                const numParents = Math.max(2, Math.floor(SIM_CONFIG.FIXED_POPULATION_SIZE * SIM_CONFIG.PARENT_SELECTION_PERCENTAGE));
                const parents = sortedCreatures.slice(0, numParents);

                if (parents.length < 2 || parents[0].fitness <= 0) {
                    console.warn("Not enough fit creatures survived to reproduce! Starting a fresh, random population.");
                    this.startNewGeneration(Array(SIM_CONFIG.FIXED_POPULATION_SIZE).fill(null).map(() => new Creature(
                        Math.random() * SIM_CONFIG.WORLD_WIDTH,
                        Math.random() * SIM_CONFIG.WORLD_HEIGHT
                    )));
                    return;
                }

                const newGenerationCreatures = [];
                while (newGenerationCreatures.length < SIM_CONFIG.FIXED_POPULATION_SIZE) {
                    const parent1 = parents[Math.floor(Math.random() * parents.length)];
                    let parent2 = parent1;
                    while (parent2 === parent1) {
                        parent2 = parents[Math.floor(Math.random() * parents.length)];
                    }

                    // Crossover brains
                    const offspringBrain = NeuralNetwork.crossover(parent1.brain, parent2.brain);
                    // Mutate offspring brain
                    const mutatedOffspringBrain = offspringBrain.cloneAndMutate(offspringBrain, (parent1.fitness + parent2.fitness) / 2, this.mutationRate, this.mutationStrength);

                    // Mutate physical traits
                    const offspringSpeed = parent1.speed + (Math.random() - 0.5) * this.mutationStrength;
                    const offspringSize = parent1.size + (Math.random() - 0.5) * this.mutationStrength * 1.5;
                    const offspringVisionRange = parent1.mutateVisionRange(parent1.visionRange, this.mutationRate, this.mutationStrength);

                    newGenerationCreatures.push(new Creature(
                        Math.random() * SIM_CONFIG.WORLD_WIDTH,
                        Math.random() * SIM_CONFIG.WORLD_HEIGHT,
                        parent1.mutateColor(parent1.originalColor, this.mutationRate),
                        clamp(offspringSpeed, 0.5, SIM_CONFIG.BASE_SPEED * 2.5),
                        clamp(offspringSize, 3, 15),
                        mutatedOffspringBrain,
                        clamp(offspringVisionRange, 50, 300)
                    ));
                }

                this.startNewGeneration(newGenerationCreatures);
            }

            /**
             * Starts a new generation with a given set of creatures.
             * @param {Creature[]} newCreatures - Array of creatures for the new generation.
             */
            startNewGeneration(newCreatures) {
                this.currentGenerationNumber++;
                this.simulationFrameCount = 0;
                this.lastGenerationStartTime = performance.now();

                this.creatures = newCreatures;
                this.resetAndSpawnAllFood(this.foodCount);

                UIManager.updateGenerationCount(this.currentGenerationNumber);
                UIManager.updatePopulationCount(this.creatures.filter(c => c.isAlive).length);
                UIManager.updateGenerationProgress(0);
                UIManager.updateBrainDisplays(this.creatures);
            }

            /**
             * The main animation loop that calls update and draw.
             * @param {DOMHighResTimeStamp} timestamp - The current time provided by requestAnimationFrame.
             */
            gameLoop(timestamp) {
                if (timestamp < this.lastFrameTime + this.msPerFrame) {
                    this.animationFrameId = requestAnimationFrame((ts) => this.gameLoop(ts));
                    return;
                }

                this.lastFrameTime = timestamp;

                this.update();
                this.draw();

                this.animationFrameId = requestAnimationFrame((ts) => this.gameLoop(ts));
            }

            /**
             * Updates the state of the simulation each frame.
             */
            update() {
                this.simulationFrameCount++;
                const currentTime = performance.now();

                let generationEnded = false;
                let aliveCreaturesThisFrame = 0;
                let maxAgeReachedCount = 0;

                for (let i = this.creatures.length - 1; i >= 0; i--) {
                    const creature = this.creatures[i];
                    if (creature.isAlive) {
                        creature.update(this.biomeMap, this.food, this.mutationRate, this.mutationStrength);

                        // Collision detection for eating (only for alive creatures)
                        for (let j = this.food.length - 1; j >= 0; j--) {
                            const f = this.food[j];
                            const dist = Math.sqrt((creature.x - f.x) ** 2 + (creature.y - f.y) ** 2);
                            if (dist < creature.size + f.radius + SIM_CONFIG.COLLISION_RADIUS_OFFSET) {
                                creature.eat(j, this.food);
                                break;
                            }
                        }
                        if (creature.isAlive) {
                            aliveCreaturesThisFrame++;
                        }
                    } else {
                        maxAgeReachedCount++;
                    }
                }

                this.replenishFood(1);

                UIManager.updatePopulationCount(aliveCreaturesThisFrame);

                if (this.currentGenerationEndMode === 'majorityMaxAge') {
                    const majorityReached = maxAgeReachedCount > (SIM_CONFIG.FIXED_POPULATION_SIZE / 2);
                    if (majorityReached || aliveCreaturesThisFrame === 0) {
                        generationEnded = true;
                    }
                    const progress = Math.min(100, Math.floor((maxAgeReachedCount / SIM_CONFIG.FIXED_POPULATION_SIZE) * 100));
                    UIManager.updateGenerationProgress(progress);
                } else if (this.currentGenerationEndMode === 'fixedTime') {
                    if (currentTime - this.lastGenerationStartTime >= this.fixedTimeGenerationLengthMs) {
                        generationEnded = true;
                    }
                    const elapsed = currentTime - this.lastGenerationStartTime;
                    const progress = Math.min(100, Math.floor((elapsed / this.fixedTimeGenerationLengthMs) * 100));
                    UIManager.updateGenerationProgress(progress);
                }

                if (generationEnded) {
                    this.endGenerationAndStartNewOne();
                }
            }

            /**
             * Draws all elements on the canvas.
             */
            draw() {
                this.ctx.clearRect(0, 0, SIM_CONFIG.WORLD_WIDTH, SIM_CONFIG.WORLD_HEIGHT);

                this.drawBiomes();

                for (const f of this.food) {
                    f.draw(this.ctx, this.showFood);
                }

                let bestCreature = null;
                let highestFitness = -1;

                for (const creature of this.creatures) {
                    creature.draw(this.ctx);
                    if (creature.isAlive && creature.calculateFitness(this.biomeMap) > highestFitness) {
                        highestFitness = creature.calculateFitness(this.biomeMap);
                        bestCreature = creature;
                    }
                }

                // Highlight the best creature with a yellow ring
                if (bestCreature) {
                    this.ctx.beginPath();
                    this.ctx.arc(bestCreature.x, bestCreature.y, bestCreature.size + 3, 0, Math.PI * 2);
                    this.ctx.strokeStyle = 'yellow';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            }
        }

        // Initialize the simulation when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new Simulation();
        });
    </script>
</body>
</html>
